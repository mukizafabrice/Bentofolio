import { h as RouterProvider, Q as invariant, W as useFogOFWarDiscovery, p as FrameworkContext, s as RemixErrorBoundary, C as decodeViaTurboStream, x as createClientRoutes, ai as matchRoutes, U as shouldHydrateRouteLoader, G as deserializeErrors2, z as createRouter, w as createBrowserHistory, T as mapRouteProperties, K as getSingleFetchDataStrategy, J as getPatchRoutesOnNavigationFunction, y as createClientRoutesWithHMRRevalidationOptOut } from '../common/chunk-SYFQ2XB5-1e8343ed.js';
import { createElement, useState, useLayoutEffect, Fragment } from 'react';
import { flushSync } from 'react-dom';
import 'turbo-stream';
import 'cookie';
import 'set-cookie-parser';

/**
 * react-router v7.1.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function RouterProvider2(props) {
  return /* @__PURE__ */ createElement(RouterProvider, {flushSync: flushSync, ...props});
}
var ssrInfo = null;
var router = null;
function initSsrInfo() {
  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {
    ssrInfo = {
      context: window.__reactRouterContext,
      manifest: window.__reactRouterManifest,
      routeModules: window.__reactRouterRouteModules,
      stateDecodingPromise: void 0,
      router: void 0,
      routerInitialized: false
    };
  }
}
function createHydratedRouter() {
  initSsrInfo();
  if (!ssrInfo) {
    throw new Error("You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`");
  }
  let localSsrInfo = ssrInfo;
  if (!ssrInfo.stateDecodingPromise) {
    let stream = ssrInfo.context.stream;
    invariant(stream, "No stream found for single fetch decoding");
    ssrInfo.context.stream = void 0;
    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {
      ssrInfo.context.state = value.value;
      localSsrInfo.stateDecodingPromise.value = true;
    }).catch((e) => {
      localSsrInfo.stateDecodingPromise.error = e;
    });
  }
  if (ssrInfo.stateDecodingPromise.error) {
    throw ssrInfo.stateDecodingPromise.error;
  }
  if (!ssrInfo.stateDecodingPromise.value) {
    throw ssrInfo.stateDecodingPromise;
  }
  let routes = createClientRoutes(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.isSpaMode);
  let hydrationData = void 0;
  if (!ssrInfo.context.isSpaMode) {
    hydrationData = {
      ...ssrInfo.context.state,
      loaderData: {...ssrInfo.context.state.loaderData}
    };
    let initialMatches = matchRoutes(routes, window.location, window.__reactRouterContext?.basename);
    if (initialMatches) {
      for (let match of initialMatches) {
        let routeId = match.route.id;
        let route = ssrInfo.routeModules[routeId];
        let manifestRoute = ssrInfo.manifest.routes[routeId];
        if (route && manifestRoute && shouldHydrateRouteLoader(manifestRoute, route, ssrInfo.context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {
          delete hydrationData.loaderData[routeId];
        } else if (manifestRoute && !manifestRoute.hasLoader) {
          hydrationData.loaderData[routeId] = null;
        }
      }
    }
    if (hydrationData && hydrationData.errors) {
      hydrationData.errors = deserializeErrors2(hydrationData.errors);
    }
  }
  let router2 = createRouter({
    routes,
    history: createBrowserHistory(),
    basename: ssrInfo.context.basename,
    hydrationData,
    mapRouteProperties,
    dataStrategy: getSingleFetchDataStrategy(ssrInfo.manifest, ssrInfo.routeModules, () => router2),
    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.isSpaMode, ssrInfo.context.basename)
  });
  ssrInfo.router = router2;
  if (router2.state.initialized) {
    ssrInfo.routerInitialized = true;
    router2.initialize();
  }
  router2.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;
  window.__reactRouterDataRouter = router2;
  return router2;
}
function HydratedRouter() {
  if (!router) {
    router = createHydratedRouter();
  }
  let [criticalCss, setCriticalCss] = useState( ssrInfo?.context.criticalCss );
  {
    if (ssrInfo) {
      window.__reactRouterClearCriticalCss = () => setCriticalCss(void 0);
    }
  }
  let [location, setLocation] = useState(router.state.location);
  useLayoutEffect(() => {
    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {
      ssrInfo.routerInitialized = true;
      ssrInfo.router.initialize();
    }
  }, []);
  useLayoutEffect(() => {
    if (ssrInfo && ssrInfo.router) {
      return ssrInfo.router.subscribe((newState) => {
        if (newState.location !== location) {
          setLocation(newState.location);
        }
      });
    }
  }, [location]);
  invariant(ssrInfo, "ssrInfo unavailable for HydratedRouter");
  useFogOFWarDiscovery(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.isSpaMode);
  return /* @__PURE__ */ createElement(Fragment, null, /* @__PURE__ */ createElement(FrameworkContext.Provider, {
    value: {
      manifest: ssrInfo.manifest,
      routeModules: ssrInfo.routeModules,
      future: ssrInfo.context.future,
      criticalCss,
      isSpaMode: ssrInfo.context.isSpaMode
    }
  }, /* @__PURE__ */ createElement(RemixErrorBoundary, {location}, /* @__PURE__ */ createElement(RouterProvider2, {router}))), /* @__PURE__ */ createElement(Fragment, null));
}

export { HydratedRouter, RouterProvider2 as RouterProvider };
